In this project, in the first step, the artificial intelligence models named “Grok 3 (Python-1), ChatGPT 4.0/Turbo (Python-2), Deepseek R1 (Python-3), Gemini 2.5 Pro (Python-4)” were given common prompts for analysis methods (Particles: threshold=50 for Connected Components, Contour and black pixels: threshold=10 for Pore% detection) and asked to produce Python codes (to detect; Number of Particles (NOP): Total particles detected (unitless). Total Area (TA): Sum of all particle areas (square pixels, px²). Average Size (AS): Mean particle area (Total Area/Number of Particles, px²). Area % (A): Percentage of the image covered by particles. Pores % (P): Percentage of the image covered by black pixels.). In the second step, the Python codes produced by the artificial intelligence models were uploaded to the online code environment to perform image scans of 25 SEM photographs belonging to our noodle project and to calculate their basic metrics. In the third step, the image scan results of each analysis were transferred to Excel and compared, and the tables of the calculations were presented in the results and discussion section. Additionally, ImageJ, a well-established Java-based image analysis software, was used for comparison. ImageJ-Fiji image scanning software, which works with Java coding language, was used to determine parameters [45-48].
Common prompts were used for all AI tools. These prompts were written to four different AI models, the code generated by each AI model was pasted into any online environment that can run Python code (for example Google Colab “https://colab.research.google.com/”), and 25 SEM images were uploaded simultaneously to “/content/” and after the installation process (!pip install opencv-python, !pip install numpy, !pip install pandas) the code was run.
Common Prompt for Connected Components method: Create a OpenCv Python script that analyzes 25 grayscale SEM images (named 1.png to 25.png in /content/) by: Applying binary thresholding (threshold value=50, THRESH_BINARY_INV) to isolate particles, using connected components analysis (cv2.connectedComponentsWithStats), measure “Number of Particles”, “Total Area (px²)”, “Average Size (px²)”, “Area %”, give results. 
Common Prompt for Contour method: Create a OpenCv Python script that analyzes 25 grayscale SEM images (named 1.png to 25.png in /content/) by: Applying invert binary thresholding (threshold value = 50, THRESH_BINARY_INV) to isolate particles, using contour (cv2.findContours) with RETR_EXTERNAL, measure “Number of Particles”, “Total Area (px²)”, “Average Size (px²)”, “Area %”, give results.
Common Prompt for Pores%: “Create a OpenCv Python script that analyzes 25 grayscale SEM images (named 1.png to 25.png in /content/) by: Applying binary thresholding (threshold value = 10, THRESH_BINARY) to detecting black pixel percentage as “Pore %”, when the analysis is completed, the results will be displayed on the screen.”
Explanation about prompts and working method: There are 3 layers in the samples; 1-pores, 2-noodle surface and 3-particles on this surface. Since particles often appear darker than the background (noodle’s surface) when photographed with an electron microscope, “cv2.THRESH_BINARY_INV” can effectively separate the particles (making particles white, 255) from the background (making background black, 0) in contour and connected components methods. For contour detection, “cv2.RETR_EXTERNAL” is useful as it focuses only on the outermost objects, ignoring holes and nested contours to simplify and speed up processing. Black pixels (Pores%) that aren't particles don't require contour or connected components methods. Since the pore results for Python and Java are the same, they are not repeated in the other tables. 
